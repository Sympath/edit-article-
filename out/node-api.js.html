<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: node-api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: node-api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const glob = require("glob");
const fs = require("fs");
const path = require("path");
const { exec } = require("node:child_process");
const shell = require("shelljs");
const { promisify } = require('util')
const os = require('os')
const utils = require(".");
/** 判断文件是否存在
 *
 * @param {*} filePath
 * @returns Boolean
 */
const fileIsExist = async function (filePath) {
  return await fs.promises
    .access(filePath)
    .then(() => true)
    .catch((_) => false);
};

/** 写入文件
 * @param {*} path
 * @param {*} buffer
 */
const writeFileRecursive = function (path, buffer) {
  return new Promise((res, rej) => {
    let lastPath = path.substring(0, path.lastIndexOf("/"));
    fs.mkdir(lastPath, { recursive: true }, (err) => {
      if (err) return rej(err);
      fs.writeFile(path, buffer, function (err) {
        if (err) return rej(err);
        return res(null);
      });
    });
  });
};

/**
 * @param {string} command process to run
 * @param {string[]} args commandline arguments
 * @returns {Promise&lt;void>} promise
 */
const runCommand = function (command, args) {
  const cp = require("child_process");
  return new Promise((resolve, reject) => {
    cp.exec(`${command} ${args.join(' ')}`, (error, stdout, stderr) => {
      if (error) {
        reject(error);
      } else {
        resolve(stdout);
      }
    });
  });
};
/** 获取指定目录下所有文件的导出信息
 * 
 * @param {*} dirPath 指定目录 需要绝对路径
 * @param {*} suffix 后缀
 * @param {*} opts：方法本身的配置对象  
 *          1. removeRequireCache 是否清除require缓存，在【应用启动过程中会修改源码】的场景下执行
 *          2. needAbsPath 是否挂载文件绝对路径信息再返回
 *          3. globOpts glob的配置对象
 */
function getFileExportObjInDir(dirPath, suffix = "js", opts = {}) {
  let {
    removeRequireCache,
    needAbsPath = true,
    globOpts = {}
  } = opts
  // 利用glob实现自动引入所有命令实现
  const files = glob.sync(`${dirPath}/*.${suffix}`, {
    ...globOpts,
  });
  const controllers = {};
  files.forEach((key) => {
    const name = key.split("/").pop().replace(/\.js/g, "");
    if (removeRequireCache) {
      delete require.cache[key]
    }
    const value = require(key);
    // 挂载文件绝对路径信息
    if (needAbsPath) {
      value._absPath = key
    }
    controllers[name] = value;
  });
  return controllers;
}
/** 加载指定文件夹下指定后缀的文件路径列表 （不给exts参数时则获取所有类型文件）
 * @param {*} dirPath 
 * @param {*} names Array 文件名数组 []
 */
function loadPathByName(dirPath, names) {
  //  @return [[filePath, dirs = []]] 返回一个二维数组 第一个元素是文件地址；第二个是对应的信息对象 { resolveDirs 相对根路径的目录数组 dirPath 父路径 }
  let ignoreNames = ['node_modules']
  function loadPathByNameCore(dirPath, names, currentDir = []) {
    if (currentDir.length === 0) {
      // 取最后一个目录名作为初始目录
      currentDir = [dirPath.split('/').pop()]
    }
    let arrFiles = []  // 最终的结果
    let arrFile = [];
    // 1. 读取指定目录内的所有子文件
    const files = fs.readdirSync(dirPath)
    for (let i = 0; i &lt; files.length; i++) {
      const item = files[i]
      // 2. 如果和指定名称匹配 则存入结果数组中
      if (names.includes(item)) {
        arrFile = [dirPath + '/' + item, {
          resolveDirs: JSON.parse(JSON.stringify(currentDir)),// 相对根路径的目录数组
          dirPath // 父路径
        }]
        arrFiles.push(arrFile)
      }
      // 3. 判断是否是文件夹，是则递归处理
      const stat = fs.lstatSync(dirPath + '/' + item)
      if (stat.isDirectory() === true &amp;&amp; !ignoreNames.includes(item)) {
        currentDir.push(item)
        arrFiles.push(...loadPathByNameCore(dirPath + '/' + item, names, currentDir))
      }
    }
    currentDir.pop()
    return arrFiles
  }
  return loadPathByNameCore(dirPath, names)
}

/** 加载指定文件夹下指定后缀的文件路径列表 （不给exts参数时则获取所有类型文件）
 * @param {*} dirPath 
 * @param {*} exts Array 文件类型数组 [mp4]
 * @param {*} cb Function 可以在存入时对存入对象进行一层拦截处理
 * @return [[filePath, dirs = []]] 返回一个二维数组 第一个元素是文件地址；第二个是对应的子目录数组
 */
function loadFileNameByPath4Ext(dirPath, exts, cb = (item) => item) {
  function loadFileNameByPath4ExtCore(dirPath, exts, cb = (item) => item, currentDir = []) {
    if (currentDir.length === 0) {
      // 取最后一个目录名作为初始目录
      currentDir = [dirPath.split('/').pop()]
    }
    let arrFiles = []
    let arrFile = [];
    const files = fs.readdirSync(dirPath)
    for (let i = 0; i &lt; files.length; i++) {
      const item = files[i]
      const stat = fs.lstatSync(dirPath + '/' + item)
      if (stat.isDirectory() === true) {
        currentDir.push(item)
        arrFiles.push(...loadFileNameByPath4Ext(dirPath + '/' + item, exts, cb, currentDir))
      } else {
        if (exts != undefined &amp;&amp; exts != null &amp;&amp; exts.length > 0) {
          for (let j = 0; j &lt; exts.length; j++) {
            let ext = exts[j];
            if (item.split('.').pop().toLowerCase() == ext.trim().toLowerCase()) {
              arrFile = [dirPath + '/' + item, JSON.parse(JSON.stringify(currentDir))]
              let handlerItem = cb(arrFile)
              // 如果排除属性存在，则不做任何处理
              if (handlerItem.exclude) {

              } else {
                arrFiles.push(handlerItem)
              }
              break;
            }
          }
        } else {
          arrFile = [dirPath + '/' + item, JSON.parse(JSON.stringify(currentDir))]
          let handlerItem = cb(arrFile)
          // 如果排除属性存在，则不做任何处理
          if (handlerItem.exclude) {

          } else {
            arrFiles.push(handlerItem)
          }
        }
      }
    }
    currentDir.pop()
    return arrFiles
  }
  return loadFileNameByPath4ExtCore(dirPath, exts, cb, [])
}

/** 对exec进行一个简单的封装，返回的是一个Promise对象，便于处理。
 * @return Promise
 */
function doShellCmd(cmd) {
  let str = cmd;
  let result = {};

  return new Promise(function (resolve, reject) {
    try {
      exec(str, function (err, stdout, stderr) {
        if (err) {
          console.log('err');
          result.errCode = 500;
          result.data = "操作失败！请重试";
          result.stderr = stderr;
          reject(result);
        } else {
          console.log('stdout ', stdout);//标准输出
          result.errCode = 200;
          result.data = "操作成功！";
          result.stdout = stdout;
          resolve(result);
        }
      })
    } catch (error) {
      throw new Error(error)
    }

  })
}
/** 获取当前操作系统
 * @returns obj
 */
function getPlatForm() {
  const platform = os.platform()
  let isLinux, isMac, isWindows;
  switch (platform) {
    case 'darwin':
      isMac = true;
      break;
    case 'linux':
      isLinux = true;
      break;
    case 'win32':
      isWindows = true;
      break;
    default:

  }
  return {
    isLinux, isMac, isWindows
  }
}

/** 根据命令获取对应的包管理器
 * 
 * @param {*} command 
 */
function getPackageManageByCommand(command) {
  let {
    isLinux, isMac, isWindows
  } = getPlatForm()
  if (!isMac) {
    throw new Error(`非mac平台请手动安装${command}命令`)
  }
  // w-todo 待实现添加系统判断
  let commandPackageMangeMap = {
    npm: ['live-server', 'qt'],
    brew: ['tree'],
  }
  let target = ''
  utils.eachObj(commandPackageMangeMap, (packageMange, commands) => {
    if (commands.includes(command)) {
      target = packageMange
    }
  })
  return target
}
let nodeApi = {
  fileIsExist,
  writeFileRecursive,
  shell,
  exec: promisify(exec),
  runCommand,
  getFileExportObjInDir,
  getPlatForm,
  getPackageManageByCommand,
  loadPathByName,
  loadFileNameByPath4Ext,
  doShellCmd
};
module.exports = nodeApi</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="VscodeApi.html">VscodeApi</a></li></ul><h3>Global</h3><ul><li><a href="global.html#doShellCmd">doShellCmd</a></li><li><a href="global.html#eachObj">eachObj</a></li><li><a href="global.html#fileIsExist">fileIsExist</a></li><li><a href="global.html#getFileExportObjInDir">getFileExportObjInDir</a></li><li><a href="global.html#getPackageManageByCommand">getPackageManageByCommand</a></li><li><a href="global.html#getPlatForm">getPlatForm</a></li><li><a href="global.html#loadFileNameByPath4Ext">loadFileNameByPath4Ext</a></li><li><a href="global.html#loadPathByName">loadPathByName</a></li><li><a href="global.html#runCommand">runCommand</a></li><li><a href="global.html#typeCheck">typeCheck</a></li><li><a href="global.html#writeFileRecursive">writeFileRecursive</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Tue Sep 27 2022 21:36:04 GMT+0800 (中国标准时间)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
